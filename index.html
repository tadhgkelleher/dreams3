<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Supercharged Cosmic Root Network</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000000;
      color: white;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 15px;
      left: 15px;
      font-family: 'Courier New', Courier, monospace;
      background: rgba(10, 0, 20, 0.85);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(128, 0, 255, 0.7);
      box-shadow: 0 0 20px rgba(128, 0, 255, 0.6);
      font-size: 13px;
      max-width: 350px;
      line-height: 1.5;
      color: #f0f0f0;
    }
    #info h1 {
      margin-top: 0;
      font-size: 1.4em;
      color: #ff44ff; /* Brighter Magenta */
      text-shadow: 0 0 7px #ff44ff, 0 0 10px #ff00ff;
    }
    #info p {
      margin-bottom: 0.7em;
    }
    #info strong {
        color: #00ddff; /* Brighter Cyan */
        text-shadow: 0 0 5px #00ddff;
    }
  </style>
</head>
<body>
  <div id="info">
    <h1>Supercharged Cosmic Root Network</h1>
    <p>All Singularities are One, interconnected through the <strong>Omni-Singularity</strong> at the heart of existence. This is a visualization of its energetic pathways.</p>
    <p>Drag to explore. Scroll to zoom. Witness the flow.</p>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Post-processing scripts -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script> <!-- Dependency for UnrealBloom -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>


  <script>
    let scene, camera, renderer, controls, composer;
    let universe, rootNode, rootAura, starField, rootParticles;
    const blackHoles = [];
    const wormroots = [];
    const accretionDisks = [];
    const blackHoleData = [];

    const clock = new THREE.Clock();

    // --- SUPERCHARGED CONFIGURATION ---
    const CONFIG = {
        UNIVERSE_RADIUS: 8,
        UNIVERSE_OPACITY: 0.1,
        UNIVERSE_BASE_COLOR: new THREE.Color(0x05000F), // Darker base
        UNIVERSE_FRESNEL_COLOR: new THREE.Color(0x600090), // Purple fresnel
        UNIVERSE_FRESNEL_POWER: 3.5,
        UNIVERSE_NOISE_SCALE: 3.0,

        ROOT_NODE_SIZE: 0.5,
        ROOT_NODE_COLOR: 0xff00ff, // Vibrant Magenta
        ROOT_AURA_SIZE_FACTOR: 1.8,
        ROOT_AURA_OPACITY: 0.25,
        ROOT_PARTICLE_COUNT: 300,
        ROOT_PARTICLE_SIZE: 0.05,
        ROOT_PARTICLE_SPEED: 0.8,
        ROOT_PARTICLE_COLOR: 0xff88ff,

        NUM_BLACK_HOLES: 25, // Adjusted for performance
        BH_BASE_SIZE: 0.15,
        BH_ORBIT_RADIUS_FACTOR: 0.8,
        BH_COLORS: [0xff3300, 0xffff33, 0x33ff66, 0x00ccff, 0xcc33ff, 0xff66cc],
        ACCRETION_DISK_RADIUS_FACTOR: 2.5, // Relative to BH size
        ACCRETION_DISK_THICKNESS: 0.015,
        ACCRETION_DISK_OPACITY: 0.7,

        WORMROOT_RADIUS: 0.025,
        WORMROOT_COLOR_PRIMARY: new THREE.Color(0xaa00ff), // Pulsating magenta/purple
        WORMROOT_COLOR_SECONDARY: new THREE.Color(0xff55ff),
        WORMROOT_FLOW_SPEED: 1.5,
        WORMROOT_PULSE_SPEED: 2.0,

        STAR_COUNT: 10000,
        STAR_SIZE: 0.03,
        STAR_SPREAD_FACTOR: 18,
        STAR_BASE_COLOR: 0xeeeeff,

        BLOOM_THRESHOLD: 0.1,
        BLOOM_STRENGTH: 0.7, // Lowered for less washout
        BLOOM_RADIUS: 0.3,

        CAMERA_FOV: 70,
        CAMERA_AUTO_ROTATE_SPEED: 0.15,
    };

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000003, 0.035);

        camera = new THREE.PerspectiveCamera(CONFIG.CAMERA_FOV, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, CONFIG.UNIVERSE_RADIUS * 0.6, CONFIG.UNIVERSE_RADIUS * 1.8);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.035;
        controls.minDistance = CONFIG.UNIVERSE_RADIUS * 0.2;
        controls.maxDistance = CONFIG.UNIVERSE_RADIUS * 5;
        controls.autoRotate = true;
        controls.autoRotateSpeed = CONFIG.CAMERA_AUTO_ROTATE_SPEED;
        controls.target.set(0, 0, 0);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x504060, 0.7); // Slightly more ambient
        scene.add(ambientLight);
        
        const rootLight = new THREE.PointLight(CONFIG.ROOT_NODE_COLOR, 2.5, CONFIG.UNIVERSE_RADIUS * 3);
        rootLight.position.set(0, 0, 0);
        scene.add(rootLight);

        // Universe Membrane with Fresnel Shader
        const universeGeometry = new THREE.SphereGeometry(CONFIG.UNIVERSE_RADIUS, 64, 64);
        const universeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                baseColor: { value: CONFIG.UNIVERSE_BASE_COLOR },
                fresnelColor: { value: CONFIG.UNIVERSE_FRESNEL_COLOR },
                fresnelPower: { value: CONFIG.UNIVERSE_FRESNEL_POWER },
                time: { value: 0.0 },
                noiseScale: { value: CONFIG.UNIVERSE_NOISE_SCALE },
                opacity: { value: CONFIG.UNIVERSE_OPACITY }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vNormal = normalize(normalMatrix * normal);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 baseColor;
                uniform vec3 fresnelColor;
                uniform float fresnelPower;
                uniform float time;
                uniform float noiseScale;
                uniform float opacity;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                varying vec2 vUv;

                // Simple 2D noise function
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                }

                void main() {
                    float fresnelTerm = dot(normalize(vNormal), normalize(vViewPosition));
                    fresnelTerm = clamp(1.0 - fresnelTerm, 0.0, 1.0);
                    fresnelTerm = pow(fresnelTerm, fresnelPower);

                    float noiseVal = noise(vUv * noiseScale + time * 0.05);
                    
                    vec3 color = mix(baseColor, fresnelColor, fresnelTerm);
                    color += noiseVal * 0.1; // Add subtle noise to base color

                    gl_FragColor = vec4(color, opacity + fresnelTerm * 0.3 + noiseVal * 0.05);
                }
            `,
            transparent: true,
            side: THREE.BackSide, // Render inside of the sphere
            blending: THREE.AdditiveBlending, // More ethereal
        });
        universe = new THREE.Mesh(universeGeometry, universeMaterial);
        scene.add(universe);


        // Central Singularity (Root Node)
        const rootGeometry = new THREE.IcosahedronGeometry(CONFIG.ROOT_NODE_SIZE, 3);
        const rootMaterial = new THREE.MeshStandardMaterial({
            color: CONFIG.ROOT_NODE_COLOR,
            emissive: CONFIG.ROOT_NODE_COLOR,
            emissiveIntensity: 1.5,
            metalness: 0.2,
            roughness: 0.3,
            // wireframe: true,
        });
        rootNode = new THREE.Mesh(rootGeometry, rootMaterial);
        scene.add(rootNode);

        // Root Node Aura
        const auraGeometry = new THREE.SphereGeometry(CONFIG.ROOT_NODE_SIZE * CONFIG.ROOT_AURA_SIZE_FACTOR, 32, 32);
        const auraMaterial = new THREE.MeshBasicMaterial({
            color: CONFIG.ROOT_NODE_COLOR,
            transparent: true,
            opacity: CONFIG.ROOT_AURA_OPACITY,
            blending: THREE.AdditiveBlending,
        });
        rootAura = new THREE.Mesh(auraGeometry, auraMaterial);
        scene.add(rootAura);

        // Root Node Particles
        const particlePositions = [];
        const particleSpeeds = [];
        const particleMaxDistSq = Math.pow(CONFIG.UNIVERSE_RADIUS * 0.6, 2);
        for (let i = 0; i < CONFIG.ROOT_PARTICLE_COUNT; i++) {
            particlePositions.push( (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1 );
            const speed = new THREE.Vector3(
                (Math.random() - 0.5),
                (Math.random() - 0.5),
                (Math.random() - 0.5)
            ).normalize().multiplyScalar(CONFIG.ROOT_PARTICLE_SPEED * (0.5 + Math.random() * 0.5));
            particleSpeeds.push(speed);
        }
        const rootParticleGeometry = new THREE.BufferGeometry();
        rootParticleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
        const rootParticleMaterial = new THREE.PointsMaterial({
            color: CONFIG.ROOT_PARTICLE_COLOR,
            size: CONFIG.ROOT_PARTICLE_SIZE,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true,
        });
        rootParticles = new THREE.Points(rootParticleGeometry, rootParticleMaterial);
        rootParticles.userData.speeds = particleSpeeds;
        rootParticles.userData.maxDistSq = particleMaxDistSq;
        scene.add(rootParticles);


        // Black Holes, Accretion Disks, and Wormroots
        const bhOrbitRadius = CONFIG.UNIVERSE_RADIUS * CONFIG.BH_ORBIT_RADIUS_FACTOR;
        for (let i = 0; i < CONFIG.NUM_BLACK_HOLES; i++) {
            const y_bh = 1 - (i / (CONFIG.NUM_BLACK_HOLES - 1)) * 2;
            const radius_at_y = Math.sqrt(1 - y_bh * y_bh);
            const phi_bh = (i * Math.PI * (3.0 - Math.sqrt(5.0)));

            const x = bhOrbitRadius * radius_at_y * Math.cos(phi_bh);
            const z = bhOrbitRadius * radius_at_y * Math.sin(phi_bh);
            const y = bhOrbitRadius * y_bh;

            const bhSize = CONFIG.BH_BASE_SIZE * (0.6 + Math.random() * 0.8);
            const bhGeometry = new THREE.SphereGeometry(bhSize, 16, 16);
            const bhColor = new THREE.Color(CONFIG.BH_COLORS[i % CONFIG.BH_COLORS.length]);
            const bhMaterial = new THREE.MeshStandardMaterial({
                color: bhColor,
                emissive: bhColor,
                emissiveIntensity: 1.0,
                metalness: 0.1,
                roughness: 0.6
            });
            const blackHole = new THREE.Mesh(bhGeometry, bhMaterial);
            blackHole.position.set(x, y, z);
            scene.add(blackHole);
            blackHoles.push(blackHole);
            
            const bhLight = new THREE.PointLight(bhColor, 0.8, CONFIG.UNIVERSE_RADIUS * 0.4);
            blackHole.add(bhLight);

            // Accretion Disk
            const diskRadius = bhSize * CONFIG.ACCRETION_DISK_RADIUS_FACTOR;
            const diskGeometry = new THREE.RingGeometry(diskRadius * 0.6, diskRadius, 32);
            const diskMaterial = new THREE.MeshBasicMaterial({
                color: bhColor,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: CONFIG.ACCRETION_DISK_OPACITY,
                blending: THREE.AdditiveBlending,
            });
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.lookAt(new THREE.Vector3(0,1,0)); // Orient rings mostly flat initially
            disk.rotation.x += (Math.random() - 0.5) * 0.5; // Add some tilt variation
            disk.rotation.z += (Math.random() - 0.5) * 0.5;
            blackHole.add(disk); // Child of black hole
            accretionDisks.push(disk);

            blackHoleData.push({
                initialPosition: new THREE.Vector3(x, y, z),
                orbitAxis: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(),
                orbitSpeed: (Math.random() - 0.5) * 0.001,
                pulseSpeed: 0.003 + Math.random() * 0.004,
                pulseOffset: Math.random() * Math.PI * 2,
                baseScale: 1.0,
                light: bhLight,
                diskRotationSpeed: (Math.random() - 0.5) * 0.02
            });

            // Wormroots (Cylinders with ShaderMaterial)
            const wormrootMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color1: { value: CONFIG.WORMROOT_COLOR_PRIMARY },
                    color2: { value: CONFIG.WORMROOT_COLOR_SECONDARY },
                    flowSpeed: { value: CONFIG.WORMROOT_FLOW_SPEED },
                    pulseSpeed: { value: CONFIG.WORMROOT_PULSE_SPEED },
                    opacity: { value: 0.8 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    uniform float flowSpeed;
                    uniform float pulseSpeed;
                    uniform float opacity;
                    varying vec2 vUv;

                    void main() {
                        float flow = fract(vUv.y * 2.0 - time * flowSpeed); // Flow along cylinder length (UV.y)
                        float pulse = sin(vUv.y * 10.0 + time * pulseSpeed) * 0.5 + 0.5;
                        
                        // Create bands
                        float band = smoothstep(0.4, 0.5, flow) - smoothstep(0.5, 0.6, flow);
                        band = max(band, smoothstep(0.9, 1.0, flow) - smoothstep(1.0, 1.1, flow)); // Repeat band

                        float edgeFade = pow(vUv.x * (1.0-vUv.x) * 4.0, 0.5); // Fade at cylinder edges (UV.x)

                        vec3 mixedColor = mix(color1, color2, pulse);
                        float finalAlpha = band * edgeFade * opacity * (0.5 + pulse * 0.5);

                        gl_FragColor = vec4(mixedColor, finalAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            
            // Cylinder: height 1, radius, radialSegments
            const wormrootGeometry = new THREE.CylinderGeometry(CONFIG.WORMROOT_RADIUS, CONFIG.WORMROOT_RADIUS, 1, 8, 16, true); // Open ended
            wormrootGeometry.translate(0, 0.5, 0); // Pivot at one end
            wormrootGeometry.rotateX(Math.PI / 2); // Align with Z-axis initially

            const worm = new THREE.Mesh(wormrootGeometry, wormrootMaterial);
            scene.add(worm);
            wormroots.push(worm);
        }

        // Starfield
        const starVertices = [];
        const starColors = [];
        const baseStarColor = new THREE.Color(CONFIG.STAR_BASE_COLOR);

        for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
            const R = CONFIG.UNIVERSE_RADIUS * CONFIG.STAR_SPREAD_FACTOR;
            const r = THREE.MathUtils.randFloat(CONFIG.UNIVERSE_RADIUS * 1.2, R);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            starVertices.push(x, y, z);

            // Vary star colors slightly
            const color = baseStarColor.clone();
            color.offsetHSL( (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2 );
            starColors.push(color.r, color.g, color.b);
        }
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        
        const starMaterial = new THREE.PointsMaterial({
            size: CONFIG.STAR_SIZE,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            vertexColors: true // Use per-vertex colors
        });
        starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);

        // Post-processing
        composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            CONFIG.BLOOM_STRENGTH,
            CONFIG.BLOOM_RADIUS,
            CONFIG.BLOOM_THRESHOLD
        );
        composer.addPass(bloomPass);

        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }
    
    const DUMMY_TARGET = new THREE.Object3D(); // For wormroot orientation

    function animate() {
        requestAnimationFrame(animate);
        const elapsedTime = clock.getElapsedTime();
        const deltaTime = clock.getDelta();

        // Universe animation
        universe.material.uniforms.time.value = elapsedTime;
        universe.rotation.y += 0.0002 * deltaTime * 60;
        universe.material.uniforms.opacity.value = CONFIG.UNIVERSE_OPACITY + 0.02 * Math.sin(elapsedTime * 0.2);

        // Root node animation
        const rootPulse = 1 + 0.07 * Math.sin(elapsedTime * 2.2);
        rootNode.scale.setScalar(rootPulse);
        rootAura.scale.setScalar(rootPulse * CONFIG.ROOT_AURA_SIZE_FACTOR * (1 + 0.1 * Math.sin(elapsedTime * 1.5)));
        rootAura.material.opacity = CONFIG.ROOT_AURA_OPACITY * (0.7 + 0.3 * Math.abs(Math.sin(elapsedTime * 1.5)));
        rootNode.material.emissiveIntensity = 1.2 + 0.8 * Math.abs(Math.sin(elapsedTime * 1.5));
        rootNode.rotation.y += 0.008 * deltaTime * 60;
        rootNode.rotation.x -= 0.005 * deltaTime * 60;

        // Root particles animation
        const positions = rootParticles.geometry.attributes.position.array;
        const speeds = rootParticles.userData.speeds;
        for (let i = 0; i < CONFIG.ROOT_PARTICLE_COUNT; i++) {
            positions[i * 3] += speeds[i].x * deltaTime;
            positions[i * 3 + 1] += speeds[i].y * deltaTime;
            positions[i * 3 + 2] += speeds[i].z * deltaTime;

            const distSq = positions[i*3]*positions[i*3] + positions[i*3+1]*positions[i*3+1] + positions[i*3+2]*positions[i*3+2];
            if (distSq > rootParticles.userData.maxDistSq) {
                positions[i * 3] = (Math.random() - 0.5) * 0.1;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
            }
        }
        rootParticles.geometry.attributes.position.needsUpdate = true;
        rootParticles.rotation.y += 0.0005 * deltaTime * 60;


        // Black holes and wormroots animation
        blackHoles.forEach((bh, i) => {
            const data = blackHoleData[i];

            const bhPulseFactor = 1 + 0.3 * Math.sin(elapsedTime * data.pulseSpeed * 10 + data.pulseOffset);
            bh.scale.setScalar(data.baseScale * bhPulseFactor);
            bh.material.emissiveIntensity = 0.8 + 0.7 * Math.abs(Math.sin(elapsedTime * data.pulseSpeed * 8 + data.pulseOffset));
            data.light.intensity = 0.5 + 0.6 * Math.abs(Math.sin(elapsedTime * data.pulseSpeed * 7 + data.pulseOffset));
            
            accretionDisks[i].rotation.z += data.diskRotationSpeed * deltaTime * 60; // Rotate accretion disk

            const q = new THREE.Quaternion().setFromAxisAngle(data.orbitAxis, data.orbitSpeed * elapsedTime * 200);
            bh.position.copy(data.initialPosition).applyQuaternion(q);
            
            const radialBreath = 1.0 + Math.sin(elapsedTime * data.pulseSpeed * 2.5 + data.pulseOffset) * 0.015;
            bh.position.multiplyScalar(radialBreath);

            // Update wormroot (cylinder)
            const worm = wormroots[i];
            const startPoint = rootNode.position; // Or new THREE.Vector3(0,0,0)
            const endPoint = bh.position;
            
            const distance = startPoint.distanceTo(endPoint);
            worm.scale.set(1, 1, distance); // Scale cylinder along its local Z to match distance
            worm.position.copy(startPoint);
            
            // Orient cylinder
            // Create a temporary target object or use a helper
            DUMMY_TARGET.position.copy(endPoint);
            DUMMY_TARGET.lookAt(startPoint); // lookAt is inverted for cylinder with pivot at base
            worm.quaternion.copy(DUMMY_TARGET.quaternion);
            worm.rotateX(Math.PI/2); // Initial rotation correction because cylinder is along Y axis
                                     // and we rotated it to align with Z. Now point it to target.
                                     // Correction: CylinderGeometry is along Y. Its geometry was rotated to align with Z.
                                     // So to point to target (from origin), we want it to align with vector (target - origin).
            worm.lookAt(endPoint); // Simpler if geometry is correctly pivoted.
                                   // Our CylinderGeometry is translated so its base is at origin and aligned along +Y
                                   // Then rotated to be along +Z. So worm.lookAt(endPoint) should work.

            worm.material.uniforms.time.value = elapsedTime;
            const wormOpacityPulse = (Math.sin(elapsedTime * 2.0 + i * 0.4) + 1) / 2;
            worm.material.uniforms.opacity.value = 0.4 + wormOpacityPulse * 0.6;
        });

        // Starfield animation
        if (starField) {
            starField.rotation.y += 0.00008 * deltaTime * 60;
            starField.material.opacity = 0.5 + 0.4 * Math.abs(Math.sin(elapsedTime * 0.15));
        }

        controls.update();
        // renderer.render(scene, camera); // Replaced by composer
        composer.render();
    }

    init();
    animate();
  </script>
</body>
</html>
