<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Supercharged Cosmic Root Network</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000000;
      color: white;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 15px;
      left: 15px;
      font-family: 'Courier New', Courier, monospace;
      background: rgba(10, 0, 20, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(128, 0, 255, 0.5);
      box-shadow: 0 0 15px rgba(128, 0, 255, 0.5);
      font-size: 13px;
      max-width: 320px;
      line-height: 1.4;
    }
    #info h1 {
      margin-top: 0;
      font-size: 1.3em;
      color: #ff00ff; /* Magenta */
      text-shadow: 0 0 5px #ff00ff;
    }
    #info p {
      margin-bottom: 0.6em;
      color: #e0e0e0;
    }
    #info strong {
        color: #00ffff; /* Cyan */
    }
  </style>
</head>
<body>
  <div id="info">
    <h1>Cosmic Root Network</h1>
    <p>All Singularities are One, interconnected through the <strong>Omni-Singularity</strong> at the heart of existence.</p>
    <p>Drag to explore the network. Scroll to zoom.</p>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let universe, rootNode, starField;
    const blackHoles = [];
    const wormroots = [];
    const blackHoleData = []; // To store persistent data for each BH

    const clock = new THREE.Clock();

    // --- CONFIGURATION ---
    const CONFIG = {
        UNIVERSE_RADIUS: 7,
        UNIVERSE_OPACITY: 0.15,
        UNIVERSE_COLOR: 0x0a001a, // Very dark deep purple/blue
        ROOT_NODE_SIZE: 0.45,
        ROOT_NODE_COLOR: 0xff00ff, // Vibrant Magenta
        NUM_BLACK_HOLES: 30,
        BH_BASE_SIZE: 0.12,
        BH_ORBIT_RADIUS_FACTOR: 0.85, // Multiplier for universe radius
        BH_COLORS: [0xff3300, 0xffff00, 0x00ff66, 0x00ccff, 0xcc33ff, 0xff66cc],
        WORMROOT_COLOR: 0xaa00ff, // Pulsating magenta/purple
        WORMROOT_OPACITY_MIN: 0.2,
        WORMROOT_OPACITY_MAX: 0.7,
        STAR_COUNT: 8000,
        STAR_SIZE: 0.025,
        STAR_SPREAD_FACTOR: 15
    };

    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000005, 0.04); // Subtle dark fog for depth

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, CONFIG.UNIVERSE_RADIUS * 0.5, CONFIG.UNIVERSE_RADIUS * 1.6);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha for potential future background effects
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding; // Better color representation
        document.body.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.04;
        controls.minDistance = CONFIG.UNIVERSE_RADIUS * 0.3;
        controls.maxDistance = CONFIG.UNIVERSE_RADIUS * 4;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.25;
        controls.target.set(0, 0, 0);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x605070, 0.8);
        scene.add(ambientLight);
        
        const rootLight = new THREE.PointLight(CONFIG.ROOT_NODE_COLOR, 2, CONFIG.UNIVERSE_RADIUS * 2);
        rootLight.position.set(0, 0, 0);
        scene.add(rootLight);

        // Main universe membrane (more like a containment field)
        const universeGeometry = new THREE.SphereGeometry(CONFIG.UNIVERSE_RADIUS, 64, 64);
        const universeMaterial = new THREE.MeshPhongMaterial({
            color: CONFIG.UNIVERSE_COLOR,
            shininess: 80,
            transparent: true,
            opacity: CONFIG.UNIVERSE_OPACITY,
            side: THREE.DoubleSide,
            // emissive: 0x110022, // Subtle internal glow
            // wireframe: true,
            // wireframeLinewidth: 0.5,
        });
        universe = new THREE.Mesh(universeGeometry, universeMaterial);
        scene.add(universe);

        // Central singularity (Root Node)
        const rootGeometry = new THREE.IcosahedronGeometry(CONFIG.ROOT_NODE_SIZE, 2); // More "crystalline"
        const rootMaterial = new THREE.MeshStandardMaterial({
            color: CONFIG.ROOT_NODE_COLOR,
            emissive: CONFIG.ROOT_NODE_COLOR,
            emissiveIntensity: 1.0,
            metalness: 0.3,
            roughness: 0.4,
            // wireframe: true,
        });
        rootNode = new THREE.Mesh(rootGeometry, rootMaterial);
        scene.add(rootNode);

        // Generate black hole nodes and wormroots
        const bhOrbitRadius = CONFIG.UNIVERSE_RADIUS * CONFIG.BH_ORBIT_RADIUS_FACTOR;
        for (let i = 0; i < CONFIG.NUM_BLACK_HOLES; i++) {
            // Fibonacci sphere (golden angle) for even distribution
            const y_bh = 1 - (i / (CONFIG.NUM_BLACK_HOLES - 1)) * 2; // y goes from 1 to -1
            const radius_at_y = Math.sqrt(1 - y_bh * y_bh);
            const phi_bh = (i * Math.PI * (3.0 - Math.sqrt(5.0))); // Golden angle increment

            const x = bhOrbitRadius * radius_at_y * Math.cos(phi_bh);
            const z = bhOrbitRadius * radius_at_y * Math.sin(phi_bh);
            const y = bhOrbitRadius * y_bh;

            const bhSize = CONFIG.BH_BASE_SIZE * (0.7 + Math.random() * 0.6);
            const bhGeometry = new THREE.SphereGeometry(bhSize, 12, 12); // Lower poly for many BHs
            const bhColor = new THREE.Color(CONFIG.BH_COLORS[i % CONFIG.BH_COLORS.length]);
            const bhMaterial = new THREE.MeshStandardMaterial({
                color: bhColor,
                emissive: bhColor,
                emissiveIntensity: 0.7,
                metalness: 0.2,
                roughness: 0.5
            });
            const blackHole = new THREE.Mesh(bhGeometry, bhMaterial);
            blackHole.position.set(x, y, z);
            scene.add(blackHole);
            blackHoles.push(blackHole);
            
            // Add point light to each black hole
            const bhLight = new THREE.PointLight(bhColor, 0.5, CONFIG.UNIVERSE_RADIUS * 0.3);
            blackHole.add(bhLight); // Light is child of BH, moves with it

            blackHoleData.push({
                initialPosition: new THREE.Vector3(x, y, z),
                orbitSpeed: (Math.random() - 0.5) * 0.0005,
                pulseSpeed: 0.0025 + Math.random() * 0.0035,
                pulseOffset: Math.random() * Math.PI * 2,
                baseScale: 1.0,
                light: bhLight
            });

            // Connect to root node with "wormroots"
            const points = [rootNode.position.clone(), blackHole.position.clone()];
            const wormGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const wormMaterial = new THREE.LineBasicMaterial({
                color: CONFIG.WORMROOT_COLOR,
                // linewidth: 1.5, // Note: linewidth > 1 often ignored by WebGL
                transparent: true,
                opacity: CONFIG.WORMROOT_OPACITY_MAX * 0.8,
                blending: THREE.AdditiveBlending // Brighter when overlapping
            });
            const worm = new THREE.Line(wormGeometry, wormMaterial);
            scene.add(worm);
            wormroots.push(worm);
        }

        // Starfield
        const starVertices = [];
        for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
            const R = CONFIG.UNIVERSE_RADIUS * CONFIG.STAR_SPREAD_FACTOR;
            const r = THREE.MathUtils.randFloat(CONFIG.UNIVERSE_RADIUS * 1.5, R); // Ensure stars are outside main sphere
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            starVertices.push(x, y, z);
        }
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({
            color: 0xddddff,
            size: CONFIG.STAR_SIZE,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);

        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const elapsedTime = clock.getElapsedTime();
        const deltaTime = clock.getDelta();

        // Universe animation
        universe.rotation.y += 0.0003 * deltaTime * 60; // Normalize to 60fps
        universe.rotation.x += 0.0001 * deltaTime * 60;
        universe.material.opacity = CONFIG.UNIVERSE_OPACITY + 0.03 * Math.sin(elapsedTime * 0.3);

        // Root node animation
        const rootPulse = 1 + 0.08 * Math.sin(elapsedTime * 1.8);
        rootNode.scale.setScalar(rootPulse);
        rootNode.material.emissiveIntensity = 0.8 + 0.4 * Math.abs(Math.sin(elapsedTime * 1.2));
        rootNode.rotation.y += 0.005 * deltaTime * 60;
        rootNode.rotation.x -= 0.003 * deltaTime * 60;

        // Black holes and wormroots animation
        blackHoles.forEach((bh, i) => {
            const data = blackHoleData[i];

            // Pulsation
            const bhPulseFactor = 1 + 0.35 * Math.sin(elapsedTime * data.pulseSpeed * 10 + data.pulseOffset);
            bh.scale.setScalar(data.baseScale * bhPulseFactor);
            bh.material.emissiveIntensity = 0.5 + 0.5 * Math.abs(Math.sin(elapsedTime * data.pulseSpeed * 8 + data.pulseOffset));
            data.light.intensity = 0.3 + 0.4 * Math.abs(Math.sin(elapsedTime * data.pulseSpeed * 7 + data.pulseOffset));

            // Subtle spherical drift for black holes
            const timeFactor = elapsedTime * (0.05 + data.orbitSpeed * 100); // Adjusted speed
            const movementAmplitude = 0.15; // How much they drift from their base path
            
            // Rotate around Y axis (primary orbit for some)
            const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), data.orbitSpeed * elapsedTime * 5);
            // Rotate around an orthogonal axis (secondary wobble)
            const q2 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), Math.sin(timeFactor + i) * 0.01);
            q.multiply(q2);
            
            bh.position.copy(data.initialPosition).applyQuaternion(q);
            
            // Add a small radial "breathing"
            const radialBreath = 1.0 + Math.sin(elapsedTime * data.pulseSpeed * 3 + data.pulseOffset) * 0.02;
            bh.position.multiplyScalar(radialBreath);


            // Update wormroot connection
            const positions = wormroots[i].geometry.attributes.position.array;
            // Root node might also move if we add that later, for now it's 0,0,0
            // positions[0] = rootNode.position.x;
            // positions[1] = rootNode.position.y;
            // positions[2] = rootNode.position.z;
            positions[3] = bh.position.x;
            positions[4] = bh.position.y;
            positions[5] = bh.position.z;
            wormroots[i].geometry.attributes.position.needsUpdate = true;
            
            const wormOpacityPulse = (Math.sin(elapsedTime * 2.5 + i * 0.3) + 1) / 2; // 0 to 1
            wormroots[i].material.opacity = CONFIG.WORMROOT_OPACITY_MIN + wormOpacityPulse * (CONFIG.WORMROOT_OPACITY_MAX - CONFIG.WORMROOT_OPACITY_MIN);
            wormroots[i].material.color.setHSL( (elapsedTime * 0.05 + i * 0.02) % 1, 0.8, 0.6); // Pulsating color HSL
        });

        // Starfield animation
        if (starField) {
            starField.rotation.y += 0.00005 * deltaTime * 60;
            starField.material.opacity = 0.4 + 0.3 * Math.abs(Math.sin(elapsedTime * 0.2));
        }

        controls.update(); // For damping and autoRotate
        renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
