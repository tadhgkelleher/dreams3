<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Supercharged Cosmic Root Network</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000000;
      color: white;
      font-family: 'Courier New', Courier, monospace;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(10, 0, 20, 0.9);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid rgba(128, 0, 255, 0.8);
      box-shadow: 0 0 25px rgba(128, 0, 255, 0.7);
      font-size: 14px;
      max-width: 90%;
      width: 300px;
      line-height: 1.6;
      color: #f0f0f0;
      transition: opacity 0.3s;
    }
    #info h1 {
      margin: 0 0 10px;
      font-size: 1.5em;
      color: #ff44ff;
      text-shadow: 0 0 8px #ff44ff, 0 0 12px #ff00ff;
    }
    #info p {
      margin: 0 0 8px;
    }
    #info strong {
      color: #00ddff;
      text-shadow: 0 0 6px #00ddff;
    }
    #controls {
      position: absolute;
      top: 15px;
      right: 15px;
      padding: 10px;
      background: rgba(10, 0, 20, 0.9);
      border-radius: 8px;
      border: 1px solid rgba(128, 0, 255, 0.8);
    }
    #controls button {
      padding: 8px 12px;
      background: #ff44ff;
      border: none;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
    }
    #controls button:hover {
      background: #ff66ff;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #ff44ff;
      text-shadow: 0 0 10px #ff44ff;
      display: none;
    }
    @media (max-width: 600px) {
      #info {
        font-size: 12px;
        padding: 15px;
        width: 80%;
      }
      #info h1 {
        font-size: 1.2em;
      }
      #controls {
        top: auto;
        bottom: 15px;
        right: 15px;
      }
    }
  </style>
</head>
<body>
  <div id="loading">Initializing Cosmic Network...</div>
  <div id="info">
    <h1>Supercharged Cosmic Root Network</h1>
    <p>All Singularities are One, interconnected through the <strong>Omni-Singularity</strong>. Visualize its energetic pathways.</p>
    <p>Drag to rotate. Scroll to zoom. Toggle auto-rotation below.</p>
  </div>
  <div id="controls">
    <button id="toggleRotation">Toggle Auto-Rotation</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

  <script>
    if (!window.THREE) {
      alert('Failed to load Three.js. Please check your network connection.');
      throw new Error('Three.js not loaded');
    }

    let scene, camera, renderer, controls, composer;
    let universe, rootNode, rootAura, starField, rootParticles;
    const blackHoles = [];
    const wormroots = [];
    const accretionDisks = [];
    const blackHoleData = [];
    const clock = new THREE.Clock();
    let isInitialized = false;

    const CONFIG = {
      UNIVERSE_RADIUS: 8,
      UNIVERSE_OPACITY: 0.12,
      UNIVERSE_BASE_COLOR: new THREE.Color(0x05000F),
      UNIVERSE_FRESNEL_COLOR: new THREE.Color(0x600090),
      UNIVERSE_FRESNEL_POWER: 3.5,
      UNIVERSE_NOISE_SCALE: 3.0,

      ROOT_NODE_SIZE: 0.5,
      ROOT_NODE_COLOR: 0xff00ff,
      ROOT_AURA_SIZE_FACTOR: 1.8,
      ROOT_AURA_OPACITY: 0.25,
      ROOT_PARTICLE_COUNT: 200,
      ROOT_PARTICLE_SIZE: 0.04,
      ROOT_PARTICLE_SPEED: 0.8,
      ROOT_PARTICLE_COLOR: 0xff88ff,

      NUM_BLACK_HOLES: 15,
      BH_BASE_SIZE: 0.15,
      BH_ORBIT_RADIUS_FACTOR: 0.8,
      BH_COLORS: [0xff3300, 0xffff33, 0x33ff66, 0x00ccff, 0xcc33ff, 0xff66cc],
      ACCRETION_DISK_RADIUS_FACTOR: 2.5,
      ACCRETION_DISK_THICKNESS: 0.015,
      ACCRETION_DISK_OPACITY: 0.7,

      WORMROOT_RADIUS: 0.025,
      WORMROOT_COLOR_PRIMARY: new THREE.Color(0xaa00ff),
      WORMROOT_COLOR_SECONDARY: new THREE.Color(0xff55ff),
      WORMROOT_FLOW_SPEED: 1.8,
      WORMROOT_PULSE_SPEED: 2.2,

      STAR_COUNT: 8000,
      STAR_SIZE: 0.03,
      STAR_SPREAD_FACTOR: 18,
      STAR_BASE_COLOR: 0xeeeeff,

      BLOOM_THRESHOLD: 0.1,
      BLOOM_STRENGTH: 0.6,
      BLOOM_RADIUS: 0.3,

      CAMERA_FOV: 70,
      CAMERA_AUTO_ROTATE_SPEED: 0.1,
    };

    function createUniverse() {
      const geometry = new THREE.SphereGeometry(CONFIG.UNIVERSE_RADIUS, 64, 64);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          baseColor: { value: CONFIG.UNIVERSE_BASE_COLOR },
          fresnelColor: { value: CONFIG.UNIVERSE_FRESNEL_COLOR },
          fresnelPower: { value: CONFIG.UNIVERSE_FRESNEL_POWER },
          time: { value: 0.0 },
          noiseScale: { value: CONFIG.UNIVERSE_NOISE_SCALE },
          opacity: { value: CONFIG.UNIVERSE_OPACITY }
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vViewPosition;
          varying vec2 vUv;
          void main() {
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vNormal = normalize(normalMatrix * normal);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform vec3 baseColor;
          uniform vec3 fresnelColor;
          uniform float fresnelPower;
          uniform float time;
          uniform float noiseScale;
          uniform float opacity;
          varying vec3 vNormal;
          varying vec3 vViewPosition;
          varying vec2 vUv;

          float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
          }
          float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
          }

          void main() {
            float fresnelTerm = dot(normalize(vNormal), normalize(vViewPosition));
            fresnelTerm = clamp(1.0 - fresnelTerm, 0.0, 1.0);
            fresnelTerm = pow(fresnelTerm, fresnelPower);
            float noiseVal = noise(vUv * noiseScale + time * 0.05);
            vec3 color = mix(baseColor, fresnelColor, fresnelTerm);
            color += noiseVal * 0.12;
            gl_FragColor = vec4(color, opacity + fresnelTerm * 0.3 + noiseVal * 0.06);
          }
        `,
        transparent: true,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending
      });
      universe = new THREE.Mesh(geometry, material);
      scene.add(universe);
    }

    function createRootNode() {
      const geometry = new THREE.IcosahedronGeometry(CONFIG.ROOT_NODE_SIZE, 3);
      const material = new THREE.MeshStandardMaterial({
        color: CONFIG.ROOT_NODE_COLOR,
        emissive: CONFIG.ROOT_NODE_COLOR,
        emissiveIntensity: 1.5,
        metalness: 0.2,
        roughness: 0.3
      });
      rootNode = new THREE.Mesh(geometry, material);
      scene.add(rootNode);

      const auraGeometry = new THREE.SphereGeometry(CONFIG.ROOT_NODE_SIZE * CONFIG.ROOT_AURA_SIZE_FACTOR, 32, 32);
      const auraMaterial = new THREE.MeshBasicMaterial({
        color: CONFIG.ROOT_NODE_COLOR,
        transparent: true,
        opacity: CONFIG.ROOT_AURA_OPACITY,
        blending: THREE.AdditiveBlending
      });
      rootAura = new THREE.Mesh(auraGeometry, auraMaterial);
      scene.add(rootAura);

      const particlePositions = new Float32Array(CONFIG.ROOT_PARTICLE_COUNT * 3);
      const particleSpeeds = [];
      const maxDistSq = Math.pow(CONFIG.UNIVERSE_RADIUS * 0.6, 2);
      for (let i = 0; i < CONFIG.ROOT_PARTICLE_COUNT; i++) {
        particlePositions[i * 3] = (Math.random() - 0.5) * 0.1;
        particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
        particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
        const speed = new THREE.Vector3(
          (Math.random() - 0.5),
          (Math.random() - 0.5),
          (Math.random() - 0.5)
        ).normalize().multiplyScalar(CONFIG.ROOT_PARTICLE_SPEED * (0.5 + Math.random() * 0.5));
        particleSpeeds.push(speed);
      }
      const particleGeometry = new THREE.BufferGeometry();
      particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
      const particleMaterial = new THREE.PointsMaterial({
        color: CONFIG.ROOT_PARTICLE_COLOR,
        size: CONFIG.ROOT_PARTICLE_SIZE,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
      });
      rootParticles = new THREE.Points(particleGeometry, particleMaterial);
      rootParticles.userData.speeds = particleSpeeds;
      rootParticles.userData.maxDistSq = maxDistSq;
      scene.add(rootParticles);
    }

    function createBlackHolesAndWormroots() {
      const bhOrbitRadius = CONFIG.UNIVERSE_RADIUS * CONFIG.BH_ORBIT_RADIUS_FACTOR;
      for (let i = 0; i < CONFIG.NUM_BLACK_HOLES; i++) {
        const y_bh = 1 - (i / (CONFIG.NUM_BLACK_HOLES - 1)) * 2;
        const radius_at_y = Math.sqrt(1 - y_bh * y_bh);
        const phi_bh = (i * Math.PI * (3.0 - Math.sqrt(5.0)));
        const x = bhOrbitRadius * radius_at_y * Math.cos(phi_bh);
        const z = bhOrbitRadius * radius_at_y * Math.sin(phi_bh);
        const y = bhOrbitRadius * y_bh;

        const bhSize = CONFIG.BH_BASE_SIZE * (0.6 + Math.random() * 0.8);
        const bhGeometry = new THREE.SphereGeometry(bhSize, 16, 16);
        const bhColor = new THREE.Color(CONFIG.BH_COLORS[i % CONFIG.BH_COLORS.length]);
        const bhMaterial = new THREE.MeshStandardMaterial({
          color: bhColor,
          emissive: bhColor,
          emissiveIntensity: 1.0,
          metalness: 0.1,
          roughness: 0.6
        });
        const blackHole = new THREE.Mesh(bhGeometry, bhMaterial);
        blackHole.position.set(x, y, z);
        scene.add(blackHole);
        blackHoles.push(blackHole);

        const bhLight = new THREE.PointLight(bhColor, 0.8, CONFIG.UNIVERSE_RADIUS * 0.4);
        blackHole.add(bhLight);

        const diskRadius = bhSize * CONFIG.ACCRETION_DISK_RADIUS_FACTOR;
        const diskGeometry = new THREE.RingGeometry(diskRadius * 0.6, diskRadius, 32);
        const diskMaterial = new THREE.MeshBasicMaterial({
          color: bhColor,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: CONFIG.ACCRETION_DISK_OPACITY,
          blending: THREE.AdditiveBlending
        });
        const disk = new THREE.Mesh(diskGeometry, diskMaterial);
        disk.lookAt(new THREE.Vector3(0, 1, 0));
        disk.rotation.x += (Math.random() - 0.5) * 0.5;
        disk.rotation.z += (Math.random() - 0.5) * 0.5;
        blackHole.add(disk);
        accretionDisks.push(disk);

        blackHoleData.push({
          initialPosition: new THREE.Vector3(x, y, z),
          orbitAxis: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(),
          orbitSpeed: (Math.random() - 0.5) * 0.001,
          pulseSpeed: 0.003 + Math.random() * 0.004,
          pulseOffset: Math.random() * Math.PI * 2,
          baseScale: 1.0,
          light: bhLight,
          diskRotationSpeed: (Math.random() - 0.5) * 0.02
        });

        const wormrootMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0.0 },
            color1: { value: CONFIG.WORMROOT_COLOR_PRIMARY },
            color2: { value: CONFIG.WORMROOT_COLOR_SECONDARY },
            flowSpeed: { value: CONFIG.WORMROOT_FLOW_SPEED },
            pulseSpeed: { value: CONFIG.WORMROOT_PULSE_SPEED },
            opacity: { value: 0.8 }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform float flowSpeed;
            uniform float pulseSpeed;
            uniform float opacity;
            varying vec2 vUv;

            void main() {
              float flow = fract(vUv.y * 2.0 - time * flowSpeed);
              float pulse = sin(vUv.y * 10.0 + time * pulseSpeed) * 0.5 + 0.5;
              float band = smoothstep(0.45, 0.5, flow) - smoothstep(0.5, 0.55, flow);
              band += smoothstep(0.95, 1.0, flow) - smoothstep(1.0, 1.05, flow);
              float edgeFade = pow(vUv.x * (1.0 - vUv.x) * 4.0, 0.7);
              vec3 mixedColor = mix(color1, color2, pulse);
              float finalAlpha = band * edgeFade * opacity * (0.6 + pulse * 0.4);
              gl_FragColor = vec4(mixedColor, finalAlpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide
        });

        const wormrootGeometry = new THREE.CylinderGeometry(CONFIG.WORMROOT_RADIUS, CONFIG.WORMROOT_RADIUS, 1, 8, 16, true);
        wormrootGeometry.translate(0, 0.5, 0);
        wormrootGeometry.rotateX(Math.PI / 2);
        const worm = new THREE.Mesh(wormrootGeometry, wormrootMaterial);
        scene.add(worm);
        wormroots.push(worm);
      }
    }

    function createStarfield() {
      const geometry = new THREE.SphereGeometry(CONFIG.STAR_SIZE, 8, 8);
      const material = new THREE.MeshBasicMaterial({
        color: CONFIG.STAR_BASE_COLOR,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending
      });
      const starMesh = new THREE.InstancedMesh(geometry, material, CONFIG.STAR_COUNT);
      const matrix = new THREE.Matrix4();
      const color = new THREE.Color();

      for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
        const r = THREE.MathUtils.randFloat(CONFIG.UNIVERSE_RADIUS * 1.2, CONFIG.UNIVERSE_RADIUS * CONFIG.STAR_SPREAD_FACTOR);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        matrix.setPosition(x, y, z);
        starMesh.setMatrixAt(i, matrix);
        color.set(CONFIG.STAR_BASE_COLOR).offsetHSL((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2);
        starMesh.setColorAt(i, color);
      }
      starMesh.instanceMatrix.needsUpdate = true;
      starField = starMesh;
      scene.add(starField);
    }

    function setupPostProcessing() {
      composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        CONFIG.BLOOM_STRENGTH,
        CONFIG.BLOOM_RADIUS,
        CONFIG.BLOOM_THRESHOLD
      );
      composer.addPass(bloomPass);

      const chromaticAberration = new THREE.ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          amount: { value: 0.002 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float amount;
          varying vec2 vUv;
          void main() {
            vec2 offset = amount * (vUv - 0.5);
            vec4 r = texture2D(tDiffuse, vUv + offset);
            vec4 g = texture2D(tDiffuse, vUv);
            vec4 b = texture2D(tDiffuse, vUv - offset);
            gl_FragColor = vec4(r.r, g.g, b.b, 1.0);
          }
        `
      });
      composer.addPass(chromaticAberration);
    }

    function init() {
      document.getElementById('loading').style.display = 'block';
      if (!window.WebGLRenderingContext) {
        alert('Your browser does not support WebGL.');
        return;
      }

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000003, 0.035);

      camera = new THREE.PerspectiveCamera(CONFIG.CAMERA_FOV, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, CONFIG.UNIVERSE_RADIUS * 0.6, CONFIG.UNIVERSE_RADIUS * 1.8);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.035;
      controls.minDistance = CONFIG.UNIVERSE_RADIUS * 0.2;
      controls.maxDistance = CONFIG.UNIVERSE_RADIUS * 5;
      controls.autoRotate = true;
      controls.autoRotateSpeed = CONFIG.CAMERA_AUTO_ROTATE_SPEED;
      controls.target.set(0, 0, 0);

      const ambientLight = new THREE.AmbientLight(0x504060, 0.7);
      scene.add(ambientLight);
      const rootLight = new THREE.PointLight(CONFIG.ROOT_NODE_COLOR, 2.5, CONFIG.UNIVERSE_RADIUS * 3);
      rootLight.position.set(0, 0, 0);
      scene.add(rootLight);

      createUniverse();
      createRootNode();
      createBlackHolesAndWormroots();
      createStarfield();
      setupPostProcessing();

      document.getElementById('toggleRotation').addEventListener('click', () => {
        controls.autoRotate = !controls.autoRotate;
      });

      window.addEventListener('resize', onWindowResize, false);
      document.getElementById('loading').style.display = 'none';
      isInitialized = true;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    const DUMMY_TARGET = new THREE.Object3D();

    function animate() {
      requestAnimationFrame(animate);
      if (!isInitialized) return;

      const elapsedTime = clock.getElapsedTime();
      const deltaTime = clock.getDelta();

      universe.material.uniforms.time.value = elapsedTime;
      universe.rotation.y += 0.0002 * deltaTime * 60;
      universe.material.uniforms.opacity.value = CONFIG.UNIVERSE_OPACITY + 0.02 * Math.sin(elapsedTime * 0.2);

      const rootPulse = 1 + 0.07 * Math.sin(elapsedTime * 2.2);
      rootNode.scale.setScalar(rootPulse);
      rootAura.scale.setScalar(rootPulse * CONFIG.ROOT_AURA_SIZE_FACTOR * (1 + 0.1 * Math.sin(elapsedTime * 1.5)));
      rootAura.material.opacity = CONFIG.ROOT_AURA_OPACITY * (0.7 + 0.3 * Math.abs(Math.sin(elapsedTime * 1.5)));
      rootNode.material.emissiveIntensity = 1.2 + 0.8 * Math.abs(Math.sin(elapsedTime * 1.5));
      rootNode.rotation.y += 0.008 * deltaTime * 60;
      rootNode.rotation.x -= 0.005 * deltaTime * 60;

      const positions = rootParticles.geometry.attributes.position.array;
      const speeds = rootParticles.userData.speeds;
      for (let i = 0; i < CONFIG.ROOT_PARTICLE_COUNT; i++) {
        positions[i * 3] += speeds[i].x * deltaTime;
        positions[i * 3 + 1] += speeds[i].y * deltaTime;
        positions[i * 3 + 2] += speeds[i].z * deltaTime;
        const distSq = positions[i * 3] ** 2 + positions[i * 3 + 1] ** 2 + positions[i * 3 + 2] ** 2;
        if (distSq > rootParticles.userData.maxDistSq) {
          positions[i * 3] = (Math.random() - 0.5) * 0.1;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
        }
      }
      rootParticles.geometry.attributes.position.needsUpdate = true;
      rootParticles.rotation.y += 0.0005 * deltaTime * 60;

      blackHoles.forEach((bh, i) => {
        const data = blackHoleData[i];
        const bhPulseFactor = 1 + 0.3 * Math.sin(elapsedTime * data.pulseSpeed * 10 + data.pulseOffset);
        bh.scale.setScalar(data.baseScale * bhPulseFactor);
        bh.material.emissiveIntensity = 0.8 + 0.7 * Math.abs(Math.sin(elapsedTime * data.pulseSpeed * 8 + data.pulseOffset));
        data.light.intensity = 0.5 + 0.6 * Math.abs(Math.sin(elapsedTime * data.pulseSpeed * 7 + data.pulseOffset));
        accretionDisks[i].rotation.z += data.diskRotationSpeed * deltaTime * 60;

        const q = new THREE.Quaternion().setFromAxisAngle(data.orbitAxis, data.orbitSpeed * elapsedTime * 200);
        bh.position.copy(data.initialPosition).applyQuaternion(q);
        const radialBreath = 1.0 + Math.sin(elapsedTime * data.pulseSpeed * 2.5 + data.pulseOffset) * 0.015;
        bh.position.multiplyScalar(radialBreath);

        const worm = wormroots[i];
        const startPoint = rootNode.position;
        const endPoint = bh.position;
        const distance = startPoint.distanceTo(endPoint);
        worm.scale.set(1, 1, distance);
        worm.position.copy(startPoint);
        DUMMY_TARGET.position.copy(endPoint);
        worm.lookAt(endPoint);
        worm.material.uniforms.time.value = elapsedTime;
        const wormOpacityPulse = (Math.sin(elapsedTime * 2.0 + i * 0.4) + 1) / 2;
        worm.material.uniforms.opacity.value = 0.4 + wormOpacityPulse * 0.6;
      });

      if (starField) {
        starField.rotation.y += 0.00008 * deltaTime * 60;
        starField.material.opacity = 0.5 + 0.4 * Math.abs(Math.sin(elapsedTime * 0.15));
      }

      controls.update();
      composer.render();
    }

    init();
    animate();
  </script>
</body>
</html>
